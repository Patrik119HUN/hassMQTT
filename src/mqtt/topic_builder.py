from enum import Enum, auto
from pydantic import GetCoreSchemaHandler
from pydantic_core import CoreSchema, core_schema
from typing import Any, List


class TopicType(Enum):
    SUBSCRIBER = auto()
    PUBLISHER = auto()


class Topic:
    __list: list[str] = []
    __topic_type: TopicType = None

    def __init__(self, topic_type: TopicType) -> None:
        """
        Initializes a `Topic` class object by setting its `__topic_type` attribute
        to a given value and creating an empty list called `__list`.

        Args:
            topic_type (TopicType): type of documentation to be generated by the
                function, such as code or concept, and influences the output
                structure and content.

        """
        self.__topic_type = topic_type
        self.__list = list()
        pass

    def add(self, value: str):
        self.__list.append(value)
        return self

    def pop(self):
        """
        Removed the last item from a list and returns the modified list.

        Returns:
            list: a reference to the original object.

        """
        self.__list.pop()
        return self

    def add_single_level(self):
        """
        Updates a list with a new string by concatenating it with the previous
        content using the plus operator, and then raises an error if the topic
        type is publisher.

        Returns:
            str: a list with a concatenated string and a plus sign at the end.

        """
        if self.__topic_type == TopicType.PUBLISHER:
            raise RuntimeError("Wildcards are not allowed in publisher topic")
        self.__list += "+"
        return self

    def add_multi_level(self):
        """
        Allows the addition of multiple level wildcard topics to a list, with the
        exception of publisher topics. The function appends a `#` symbol to the
        list and raises a runtime error for publisher topics.

        Returns:
            str: a new list with a # character appended, indicating that wildcards
            are not allowed in publisher topics.

        """
        if self.__topic_type == TopicType.PUBLISHER:
            raise RuntimeError("Wildcards are not allowed in publisher topic")
        self.__list += "#"
        return self

    def build(self) -> str:
        """
        Concatenates the elements of an iterable list `self.__list` separated by
        a `/`. It returns the resulting string.

        Returns:
            str: a concatenation of the elements of the `self._list` list, separated
            by slashes.

        """
        temp: str = ""
        for x in self.__list:
            temp += x + "/"
        temp = temp[:-1]
        return temp

    @property
    def get_topic_type(self):
        """
        Returns a string representing the topic type of the given code.

        Returns:
            str: a string representing the type of topic being described.

        """
        return self.__topic_type

    def __str__(self) -> str:
        """
        Builds a string representation of its instance by returning `self.build()`.
        It returns a built string object representing the instance's data in a
        specific format without modifying its original value.

        Returns:
            str: a string representation of the code object.

        """
        return self.build()

    def __eq__(self, other):
        """
        Compares two objects of the same class by returning `True` if their strings
        are equal, and `False` otherwise.

        Args:
            other (str): 2nd argument used for comparing strings, which is optional
                but provides additional context for evaluating equality between
                two string values.

        Returns:
            str: a boolean value indicating whether the object and the other
            argument are equal.

        """
        return str(self) == str(other)

    @classmethod
    def __get_pydantic_core_schema__(
        cls, source_type: Any, handler: GetCoreSchemaHandler
    ) -> CoreSchema:
        """
        Generates high-quality documentation for code given to it by creating JSON
        and Python schema files based on the `core_schema`.

        Args:
            cls (instance of `Topic`.): type of Python object that will be serialized
                and deserialized by the `core_schema.plain_serializer_function_ser_schema()`
                function.
                
                		- `json_schema`: A JSON schema defining the structure of the
                deserialized input.
                		- `python_schema`: An instance of the `IsInstanceSchema` class,
                which specifies the Python class of the deserialized input.
                		- `serialization`: A function that serializes the input to a
                JSON-compatible form, using the `plain_serializer_function` schema.
                
                	The input `cls` is destructured if appropriate, meaning its
                properties are explained in detail below. If `cls` is not destructured,
                it means that all of its properties have been explicitedly assigned
                and do not need further explanation.
            source_type (Any): type of schema that is being used to generate the
                documentation, specifically whether it is a JSON or Python schema.
            handler (GetCoreSchemaHandler): schema for the Python object that will
                be serialized, specifically an instance of the `Topic` class.

        Returns:
            CoreSchema: a Pydantic core schema dictionary representation of the
            Topic class.

        """
        return core_schema.json_or_python_schema(
            json_schema=core_schema.str_schema(),
            python_schema=core_schema.is_instance_schema(Topic),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda c: c.build()
            ),
        )


class StringToTopic:
    __topic: Topic

    def __init__(self, topic_type: TopicType, value: str):
        """
        Initializes an instance of `Topic` with a given `topic_type`. It then
        splits the input `value` into a list of strings and passes each string to
        the `add()` method of the topic instance.

        Args:
            topic_type (TopicType): type of topic that the `self.__topic` variable
                will represent after the method call.
            value (str): code documentation to be generated, which is split into
                a list of strings (`str_list`) and used to initialize a `Topic`
                object representing the topic type provided as input.

        """
        str_list: List[str] = value.split("/")
        self.__topic = Topic(topic_type)
        for x in str_list:
            self.__topic.add(x)

    def build(self) -> Topic:
        """
        Returns a reference to the current class instance's internal `self`.

        Returns:
            Topic: a string representing the documentation for the code provided.

        """
        return self.__topic
